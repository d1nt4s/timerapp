package main

import (
	"log"

	"github.com/gdamore/tcell/v2"
)

type App struct {
	screen                 tcell.Screen
	timer                  *Timer
	uiCommandCh            chan string
	acceptingTimerCommands bool
}

func NewApp() *App {
	screen, err := tcell.NewScreen()
	if err != nil {
		log.Fatalf("–æ—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —ç–∫—Ä–∞–Ω–∞: %v", err)
	}
	if err := screen.Init(); err != nil {
		log.Fatalf("–æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —ç–∫—Ä–∞–Ω–∞: %v", err)
	}

	return &App{
		screen:      screen,
		uiCommandCh: make(chan string),
	}
}

func (a *App) Run() {
	userNotice(a.screen, "‚å®Ô∏è  –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É (start / exit):")

	var timer Timer

	a.timer = &timer
	a.timer.control = make(chan string)	
	a.acceptingTimerCommands = false

	go func() {
		defer func() {
			Debug("üü¢ scanCommand –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è")
		}()
		scanCommand(a.screen, a.uiCommandCh)
	}()

Loop:
	for {

		select {
		case cmd := <-a.uiCommandCh:
			if a.acceptingTimerCommands {
				a.timer.control <- cmd
			} else {
				if a.handleCommand(cmd) {
					break Loop
				}
			}
		}
	}
}

func (a *App) handleCommand(cmd string) bool {
	switch cmd {
	case "exit":
		return true
	case "new":
		a.startTimer(1, 0)
	default:
		userError(a.screen, "ü§∑ –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞")
	}

	return false
}

func (a *App) startTimer(min, sec int) {

	a.timer.setup(sec, min)
	a.timer.status = Continue
	a.acceptingTimerCommands = true

	go func() {
		defer func() {
			a.acceptingTimerCommands = false
			Debug("üü¢ timer.run –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è")
			userNotice(a.screen, "‚è± –¢–∞–π–º–µ—Ä –∑–∞–≤–µ—Ä—à—ë–Ω")
			userHint(a.screen, "‚úèÔ∏è  –í–≤–µ–¥–∏—Ç–µ 'new' –∏–ª–∏ 'exit'")

		}()
		a.timer.run(a.screen)

	}()
}
